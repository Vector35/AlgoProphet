### Bibliography
* [`samples/`](samples/)
  * [`function_based/`](samples/function_based/): DFG generated by [`dfg.py`](dfg.py)
* [`sepmodel/`](sepmodel/)
  * [`function-based/`](sepmodel/function-based/): signature models which can be used to match algorithms
* [`model/`](model/)
  * Tests for reordering arithmetic operations
* [`dfg.py`](dfg.py): Generate DFG based on function
  * `python3 dfg.py [given binary] [function name] [arch] [optimization level]`
* [`bb_dfg.py`](bb_dfg.py): Generate DFG based on basic blocks and focus on loop
  * OLD! Might needed to be updated if we want to work more on basic blocks
* [`graph_match.py`](graph_match.py)
  * `python3 graph_match.py [models you want to use]... [given function DAG]`
* [`model_separator.py`](model_separator.py): which is used to generate signature models; however, manual effort might be preferred
* `./test.sh > ./res.txt`
* [`sample.sh`](sample.sh): generate sample DFG.

### Introduction to our DFG
`dfg.py` would generate dfg of function based on MLIL SSA form. In other words, it would assume that the results of MLIL SSA are correct.

### Algorithm
1. BUILDING DFG
2. NORMALIZATION
   1. normalization during building graph
   2. normalization after building graph
3. GRAPH MATCHING

#### BUILDING DFG

#### NORMALIZATION
Thanks to our mlil, the only normalization stuff we need to do is on arithmetic operations, and this depends on what type of operations we need in our scope.

#### GRAPH MATCHING
To cover large enough implementations, we might need multiple, generic signatures.